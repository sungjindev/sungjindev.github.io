---
title: 좋은 객체 지향 설계의 5가지 원칙
categories: [Computer science, Object Oriented Programming]
tags: [Object Oriented Programming, object, OOP, SOLID, 객체 지향 프로그래밍, 객체, 솔리드]
---

이전 포스팅에서 객체 지향 설계란 무엇인지에 대해 알아봤습니다. 이번 포스팅에서는 좋은 객체 지향 설계를 위해 필요한 5가지 원칙, 줄여서 SOLID에 대해 살펴보겠습니다.

## SOLID란?
SOLID는 Clean Code의 저자로 유명한 로버트 마틴이 좋은 객체 지향 설계 원칙을 5가지로 정리해 나타낸 것을 의미하고 이 각각의 원칙의 앞글자를 따 SOLID라고 명명하였습니다. 5가지 원칙을 살펴보면 다음과 같습니다.   
    
1. 단일 책임 원칙(Single Responsibility Principle, SRP)
2. 개방-폐쇄 원칙(Open/Closed Principle, OCP)
3. 리스코프 치환 원칙(Liskov Substitution Principle, LSP)
4. 인터페이스 분리 원칙(Interface Segregation Principle, ISP)
5. 의존 관계 역전 원칙(Dependency Inversion Principle, DIP)
   
지금부터는 이 각각의 원칙에 대해 자세하게 살펴보겠습니다.

## 단일 책임 원칙이란?
단일 책임 원칙(Single Responsibility Principe, SRP)의 정의는 "한 클래스는 하나의 책임만을 가져야 한다"입니다. 여기서 사실 **책임**이라는 단어의 의미 자체가 굉장히 모호한 단어입니다. 책임이 상황에 따라 클 수도 있고 작을 수도 있고 문맥에 따라 달라지기도 합니다. 그래서 이러한 책임을 잘 나누고 하나의 책임만을 가지게 할 수 있는 능력은 설계자의 경험에 따라 많이 달라지곤 합니다.   
    
책임이라는 것 자체가 굉장히 모호하지만 그럼에도 불구하고 좀 간단한 기준을 제시해보면 **변경**을 기준으로, 변경이 있을 때 그로 인한 여파가 적으면 단일 책임 원칙을 잘 따랐다고 판단할 수 있습니다.   
    
예를 들어서, UI에 한 부분을 바꾸는데 SQL 쿼리 코드부터 시작해서 애플리케이션 단 로직까지 모두 변경해야하면 이는 단일 책임 원칙을 잘 지키지 못했다라고 생각할 수 있습니다. UI단에서 너무 많은 책임을 가지고 의존성을 가지고 있었기 때문입니다.   
    
보통 스프링 프로젝트 같은 경우에는 정형화된 뼈대가 잘 갖추어져 있다고들 말하는데, 그런 식으로 다양한 계층을 나누는 이유 또한 단일 책임 원칙을 잘 지켜서 코드에 유연성을 주기 위함이라고 이해하면 좋습니다.   
    
책임을 잘 나누는 것이 중요하고 한 클래스에 하나의 책임만을 가지도록 잘게 쪼개는 게 코드에 유연성을 줄 수 있다는 것까지는 이해가 되는데, 그럼 어느 정도의 크기로 책임을 구분하고 나누어야 하는지가 문제가 될 수 있습니다. 왜냐하면, 책임의 범위를 너무 작게하게 되면 기능이 너무 잘개 쪼개어져서 오히려 더 손이 많이 갈수도 있고 시스템 자체가 너무 복잡해질 수도 있고 책임의 범위를 너무 크게하면 책임이 제대로 나뉘어지지 않아 하나의 책임을 가졌다고 하더라도 변경이 있을 때 다른 코드에 큰 여파를 줄 수도 있기 때문입니다.   
    
따라서, 단일 책임 원칙을 지키는 이유이자 우리의 주 목적은 변경 시 여파를 줄이기 위함이라는 것을 명심하고 이를 기준삼아 책임의 범위를 잘 지킨다면 좋은 설계를 이뤄낼 수 있을 것입니다.   

## 개방-폐쇄 원칙이란?
개방-폐쇄 원칙(Open/Closed Principle, OCP)의 정의는 "소프트웨어의 요소는 확장에 열려있고 변경에는 닫혀있어야 한다"입니다. 이 말이 처음들으면 굉장히 거짓말 같고 이해가 안되기도 했습니다. 소프트웨어 시스템에서 기능을 확장하길 바라면서 코드의 변경은 없어야 한다는 말이 가능한 말인지, 어떻게 기능을 추가하는데 코드의 변경이 없는지 납득이 잘 안되기도 합니다.  
 
이 개방-폐쇄 원칙을 제대로 이해하기 위해서는 정의에 포함된 **변경**이라는 단어에 주목할 필요가 있습니다. **여기서 말하는 변경은 기존 코드에 대한 변경**입니다. 즉, 새로운 코드가 추가되는 것은 변경이라 보지 않고 기존에 작성한 코드가 있고 이 시스템에 새로운 기능을 추가하려고 할 때 기존에 작성한 코드를 수정해야 되는지 여부를 판단한다고 생각하면 좋습니다. 잘 생각해보면 이 또한 앞서 살펴본 단일 책임 원칙과 같이 어떤 기능을 추가하거나 수정할 때 이미 작성된 다른 코드들에 대한 변경 여파에 대한 고민이라는 걸 알 수 있습니다. 다시 한번 강조하면, 핵심은 **기존 코드에 대한 변경이 가능한 없도록 선택하는 것**입니다.   
    
우리는 이를 위해서 객체 지향 언어의 다형성(Polymorphism)을 활용할 수 있습니다. 즉 인터페이스 등을 만들어 역할을 만들고 이 역할에 대해 자세한 기능들을 구현하는 구현체와 구분합니다. 우리는 새로운 기능이 필요하면 역할(인터페이스)를 건들이지 않고 새로운 구현체를 생성하면 됩니다. 이를 통해 확장에는 열려있고 변경에는 닫혀있는 코드를 짤 수 있습니다.   
    
여기서 개방-폐쇄 원칙에 대해 잘 이해가 되었는지 예시 코드를 들어 확인해보겠습니다. 스프링 프로젝트에서 Service단에서 Repository 계층에 접근하기 위해 아래와 같이 코드를 작성해줬다고 하겠습니다. 여기서 UserRepository는 인터페이스이고 이를 구현한 구현체로 MemoryUserRepository 클래스가 있다고 하겠습니다.    
    
```java
public class UserService {
    private UserRepository userRepository = new MemoryUserRepository();
}
```   
    
그런데 만약, 이 프로젝트에서 요구사항이 바뀌어서 MemoryUserRepository 대신에 Jdbc를 활용한 JdbcUserRepository를 사용하도록 바뀐다면 어떻게 해야 될까요?   
    
그렇다면 아래와 같이 코드를 변경할 수 있을 것입니다.   

```java
public class UserService {
    private UserRepository userRepository = new JdbcUserRepository();
}
```   
    
이 코드도 분명 사소한 몇 글자 안되는 수정이라고 생각하고 만족할 수도 있습니다만, 틀림없이 이 또한 기존에 존재하던 코드에 대한 변경이 필요했고 이는 개방-폐쇄 원칙을 온전히 지키고 있다라고 말할 수 없습니다.   
    
저희는 위 예시에서 분명 인터페이스(역할)과 구현체를 구분했고 다형성을 활용했습니다. 하지만 그럼에도 불구하고 이를 Service 레이어에 적용하는 과정에서 코드에 변경이 불가피했고 결국 OCP 원칙을 깨뜨려버렸습니다.   
    
이런 문제가 발생하는 근본적인 원인은 위 코드에 있습니다. Repository 역할을 사용하고자 하는 클라이언트 역할인 UserService가 자체 코드 내에서 구현 클래스를 코드로 직접 선택하고 있기 때문에 구현 클래스를 바꾸는 요구 사항에 대해서 코드를 변경하지 않고서는 요구 사항을 변경할 수 없게 만들었기 때문입니다.   
    
즉 OCP를 지키면서 구현 클래스를 바꾸려면 위 코드 자체를 뜯어 고쳐야합니다. 이걸 해결하기 위해서는 코드로 개발자가 직접 구현체를 선택하는 부분 대신에 연관 관계를 자동으로 맺어주는 별도의 설정자가 필요합니다.   
    
나중에 알게되겠지만, 이런 별도의 뭔가를 **스프링**이 이미 스프링 컨테이너라는 것을 구현해놓고 해주는 것입니다. 이를 위해 의존성 주입(Dependency Injection, DI)도 필요하고 IoC(Inversion of Control) 컨테이너도 필요합니다. 이것들까지 여기서 설명하기에는 너무 양이 방대해지므로 나누어서 다음에 진행하겠습니다.   
    
## 리스코프 치환 원칙이란?
리스코프 치환 원칙(Liskov Substitution Principle, LSP)은 "프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다"를 의미합니다.   
    
이게 처음에 저는 잘 이해가 되지 않았는데, 간단히 바꿔 말하면 **인터페이스를 구현한 구현체를 믿고 사용하기 위해 인터페이스가 담고있는 내부적인, 암묵적인 규약까지 모두 깨뜨리지 않으면서 구현해야 함을 의미한다.**   
    
단순히 프로그래밍 언어의 문법적인 검증 단계인 컴파일 단계를 성공하는 것을 넘어서 이 역할을 가져야되는 기능적인 의미까지 지켜가며 구현체를 만들어가야 한다는 의미인 것입니다.   
    
간단한 예시로 자동차라는 역할과 이를 구현하는 여러 브랜드 현대차, 기아차 등의 구현체가 있다고 들어보겠습니다. 자동차라는 역할 인터페이스 내 엑셀이라는 메서드가 정의되어 있을 때 엑셀은 우리 모두가 앞으로 가는 기능이라는 것을 암묵적으로 알고 있습니다. 이때 일부 구현체에서 이 의미를 제대로 이해하지 못하고 엑셀이 호출되었을 때 차가 뒤로 가도록 구현해버리면 이는 프로그램의 결함을 초래하고 개발자 입장에서는 구현체에 대해 100% 믿고 사용할 수 없기 때문에 신뢰성을 깨뜨리게 됩니다.   
    
즉, 역할과 구현으로 나눠 생각하는 것이 객체 지향 설계의 근간이고 핵심인데 이 **구현을 온전히 믿고 사용할 수 있도록 역할의 규약들을 모두 온전히 잘 지키자라는 것이 리스코프 치환 원칙의 핵심**입니다.    
    

## 인터페이스 분리 원칙이란?
인터페이스 분리 원칙(Interface Segregation Principle, ISP)은 "특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다."라는 의미로 생각하면 좋습니다. 예시를 들어 바로 설명해보겠습니다.   
    
예를 들어 자동차라는 인터페이스가 있을 때 동력과 관련된 엔진 인터페이스와 방향을 조절해주는 조향부 인터페이스 등으로 잘게 인터페이스를 쪼갰을 때, 자동차에 조향과 관련된 문제가 발생하면 조향 인터페이스 부분만 손봐주면 되니 오류가 퍼지는 파장도 줄어들고 고치기도 더욱 쉬워질 수 있습니다.   
    
즉, 인터페이스 하나로 여러가지 기능 혹은 책임을 범용적으로 퉁쳐서 사용하기 보다는 적당한 크기의 인터페이스 여러개로 분리하여 쪼개어주는 것이 좋다라는 의미입니다.   
    

## 의존 관계 역전 원칙이란?
의존 관계 역전 원칙(Dependency Inversion Principle, DIP)이란 "프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다"라는 원칙입니다. 이 말을 듣고 이해가 빠르신 분이라면 아까 개방-폐쇄 원칙의 예시를 떠올리실 것입니다. 아까 Service라는 클라이언트 코드가 MemoryRepository, JdbcRepository 등의 구현 클래스를 직접 바라보고 있어서 코드의 변경이 발생하는 문제가 있었는데, 이를봐도 프로그래머는 구현체에 의존해선 안되고 추상화에 의존해야 변경 가능성이 줄어든다는 것을 알 수 있습니다. 즉, 다시 말해 구현에 의존하기보다 역할에 의존하라는 말이랑 사실 똑같은 말입니다.    

## 마무리
이렇게 좋은 객체 지향 설계를 위한 원칙 5가지, SOLID에 대해 알아봤습니다. 다시 한번 정리해보면, 객체 지향 설계의 핵심은 다형성이지만 다형성만으로는 기존 코드의 변경을 모두 막을 수는 없습니다. 이런 문제는 다형성은 잘 활용했지만 역할에만 의존하지 않고 구현에도 의존할 때 발생합니다. 하지만, 단순히 Java와 같은 객체 지향 프로그래밍 언어에서 제공하는 문법적인 기능만으로는 개방-폐쇄 원칙이나 DIP를 모두 지키기 쉽지 않습니다. 그래서 뭔가 자동으로 구현체를 넣어주는 설정자 같은 기능이 필요한데 이런 기능을 스프링에서 IoC 컨테이너나 의존성 주입 등을 활용해서 제공합니다. 이에 대한 내용은 다음 포스팅에서 이어 살펴보겠습니다. 감사합니다.    

## References
* 인프런 내 김영한 강사님의 스프링 핵심 원리 - 기본편